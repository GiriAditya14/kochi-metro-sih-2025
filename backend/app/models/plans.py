from sqlalchemy import Column, Integer, String, DateTime, Float, ForeignKey, Text, Boolean, Enum as SQLEnum
from sqlalchemy.orm import relationship
from datetime import datetime
import enum
from .database import Base


class AssignmentType(str, enum.Enum):
    SERVICE = "SERVICE"  # Revenue service
    STANDBY = "STANDBY"  # Backup at depot
    IBL_MAINTENANCE = "IBL_MAINTENANCE"  # Maintenance at IBL
    IBL_CLEANING = "IBL_CLEANING"  # Cleaning at IBL
    IBL_BOTH = "IBL_BOTH"  # Both maintenance and cleaning
    OUT_OF_SERVICE = "OUT_OF_SERVICE"  # Cannot be used


class PlanStatus(str, enum.Enum):
    DRAFT = "draft"  # Being prepared
    PROPOSED = "proposed"  # Generated by optimizer
    REVIEWED = "reviewed"  # Reviewed by supervisor
    APPROVED = "approved"  # Final approved plan
    EXECUTED = "executed"  # Plan was executed
    MODIFIED = "modified"  # Plan was modified after approval


class AlertSeverity(str, enum.Enum):
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


class NightPlan(Base):
    """
    Night induction plan - the main output of the optimizer.
    Contains assignments for all trains for the next day.
    """
    __tablename__ = "night_plans"
    
    id = Column(Integer, primary_key=True, index=True)
    
    # Plan identification
    plan_id = Column(String(50), unique=True, index=True)
    plan_date = Column(DateTime, nullable=False)  # Date this plan is for
    depot_id = Column(String(20), default="MUTTOM")
    
    # Status
    status = Column(SQLEnum(PlanStatus), default=PlanStatus.DRAFT)
    
    # Plan metadata
    created_by = Column(String(100), default="system")
    approved_by = Column(String(100))
    approved_at = Column(DateTime)
    
    # Optimizer info
    optimizer_version = Column(String(20))
    optimization_time_seconds = Column(Float)
    optimization_score = Column(Float)  # Overall score
    
    # Summary statistics
    trains_in_service = Column(Integer, default=0)
    trains_standby = Column(Integer, default=0)
    trains_ibl = Column(Integer, default=0)
    trains_out_of_service = Column(Integer, default=0)
    
    # Constraint satisfaction
    hard_constraints_violated = Column(Integer, default=0)
    soft_constraints_score = Column(Float)
    
    # Scores breakdown
    reliability_score = Column(Float)  # Service readiness
    mileage_balance_score = Column(Float)  # Fleet mileage balance
    branding_score = Column(Float)  # SLA compliance
    shunting_score = Column(Float)  # Shunting efficiency
    
    # Penalties and costs
    estimated_branding_penalty = Column(Float, default=0)
    estimated_shunting_cost = Column(Float, default=0)
    
    # What-if scenario info
    is_scenario = Column(Boolean, default=False)
    scenario_name = Column(String(200))
    baseline_plan_id = Column(String(50))  # Reference to baseline for comparison
    scenario_description = Column(Text)
    
    # Notes and explanations
    notes = Column(Text)
    ai_explanation = Column(Text)  # GenAI-generated explanation
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    assignments = relationship("PlanAssignment", back_populates="plan", cascade="all, delete-orphan")
    alerts = relationship("Alert", back_populates="plan", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<NightPlan {self.plan_id}>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "plan_id": self.plan_id,
            "plan_date": self.plan_date.isoformat() if self.plan_date else None,
            "depot_id": self.depot_id,
            "status": self.status.value if self.status else None,
            "created_by": self.created_by,
            "approved_by": self.approved_by,
            "approved_at": self.approved_at.isoformat() if self.approved_at else None,
            "optimization_score": self.optimization_score,
            "trains_in_service": self.trains_in_service,
            "trains_standby": self.trains_standby,
            "trains_ibl": self.trains_ibl,
            "trains_out_of_service": self.trains_out_of_service,
            "hard_constraints_violated": self.hard_constraints_violated,
            "soft_constraints_score": self.soft_constraints_score,
            "reliability_score": self.reliability_score,
            "mileage_balance_score": self.mileage_balance_score,
            "branding_score": self.branding_score,
            "shunting_score": self.shunting_score,
            "estimated_branding_penalty": self.estimated_branding_penalty,
            "estimated_shunting_cost": self.estimated_shunting_cost,
            "is_scenario": self.is_scenario,
            "scenario_name": self.scenario_name,
            "ai_explanation": self.ai_explanation,
            "notes": self.notes,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }


class PlanAssignment(Base):
    """
    Individual train assignment within a night plan.
    """
    __tablename__ = "plan_assignments"
    
    id = Column(Integer, primary_key=True, index=True)
    
    # References
    plan_id = Column(Integer, ForeignKey("night_plans.id"), nullable=False)
    train_id = Column(Integer, ForeignKey("trains.id"), nullable=False)
    
    # Assignment
    assignment_type = Column(SQLEnum(AssignmentType), nullable=False)
    service_rank = Column(Integer)  # Order in service list (1 = first out)
    
    # Track assignment
    assigned_track = Column(String(20))
    assigned_position = Column(Integer)
    
    # Timing
    planned_departure_time = Column(DateTime)
    planned_return_time = Column(DateTime)
    
    # For IBL assignments
    ibl_tasks = Column(Text)  # JSON list of tasks
    estimated_ibl_duration_hours = Column(Float)
    assigned_bay = Column(String(20))
    
    # Scores for this assignment
    fitness_score = Column(Float)  # Based on certificates
    maintenance_score = Column(Float)  # Based on job cards
    branding_score = Column(Float)  # Based on SLA
    mileage_score = Column(Float)  # Based on km balance
    cleaning_score = Column(Float)  # Based on cleaning status
    shunting_score = Column(Float)  # Based on position
    overall_score = Column(Float)
    
    # Constraint details
    hard_constraint_violations = Column(Text)  # JSON list
    soft_constraint_issues = Column(Text)  # JSON list
    
    # Override info
    is_manual_override = Column(Boolean, default=False)
    override_by = Column(String(100))
    override_reason = Column(Text)
    original_assignment = Column(String(50))  # What optimizer suggested
    
    # Explanation
    assignment_reason = Column(Text)  # Why this assignment
    ai_explanation = Column(Text)
    
    # Notes
    notes = Column(Text)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    plan = relationship("NightPlan", back_populates="assignments")
    train = relationship("Train", back_populates="plan_assignments")
    
    def __repr__(self):
        return f"<PlanAssignment Train {self.train_id} -> {self.assignment_type}>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "plan_id": self.plan_id,
            "train_id": self.train_id,
            "assignment_type": self.assignment_type.value if self.assignment_type else None,
            "service_rank": self.service_rank,
            "assigned_track": self.assigned_track,
            "assigned_position": self.assigned_position,
            "planned_departure_time": self.planned_departure_time.isoformat() if self.planned_departure_time else None,
            "ibl_tasks": self.ibl_tasks,
            "estimated_ibl_duration_hours": self.estimated_ibl_duration_hours,
            "assigned_bay": self.assigned_bay,
            "fitness_score": self.fitness_score,
            "maintenance_score": self.maintenance_score,
            "branding_score": self.branding_score,
            "mileage_score": self.mileage_score,
            "cleaning_score": self.cleaning_score,
            "shunting_score": self.shunting_score,
            "overall_score": self.overall_score,
            "is_manual_override": self.is_manual_override,
            "override_by": self.override_by,
            "override_reason": self.override_reason,
            "assignment_reason": self.assignment_reason,
            "ai_explanation": self.ai_explanation,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }


class OverrideLog(Base):
    """
    Log of manual overrides to plans.
    For audit trail and learning.
    """
    __tablename__ = "override_logs"
    
    id = Column(Integer, primary_key=True, index=True)
    
    # References
    plan_id = Column(Integer, ForeignKey("night_plans.id"))
    assignment_id = Column(Integer, ForeignKey("plan_assignments.id"))
    train_id = Column(Integer, ForeignKey("trains.id"))
    
    # Override details
    original_assignment = Column(String(50))
    new_assignment = Column(String(50))
    
    # User info
    override_by = Column(String(100), nullable=False)
    override_role = Column(String(50))  # Supervisor, Manager, etc.
    
    # Reason
    reason_category = Column(String(50))  # Safety, Operational, Customer, Other
    reason_details = Column(Text, nullable=False)
    
    # Outcome tracking
    outcome = Column(String(50))  # Success, Issue, Unknown
    outcome_notes = Column(Text)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    
    def __repr__(self):
        return f"<OverrideLog {self.id}>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "plan_id": self.plan_id,
            "assignment_id": self.assignment_id,
            "train_id": self.train_id,
            "original_assignment": self.original_assignment,
            "new_assignment": self.new_assignment,
            "override_by": self.override_by,
            "override_role": self.override_role,
            "reason_category": self.reason_category,
            "reason_details": self.reason_details,
            "outcome": self.outcome,
            "outcome_notes": self.outcome_notes,
            "created_at": self.created_at.isoformat() if self.created_at else None
        }


class Alert(Base):
    """
    Alerts and warnings generated by the system.
    """
    __tablename__ = "alerts"
    
    id = Column(Integer, primary_key=True, index=True)
    
    # References
    plan_id = Column(Integer, ForeignKey("night_plans.id"))
    train_id = Column(Integer, ForeignKey("trains.id"))
    
    # Alert details
    alert_type = Column(String(50), nullable=False)
    severity = Column(SQLEnum(AlertSeverity), default=AlertSeverity.WARNING)
    title = Column(String(200), nullable=False)
    message = Column(Text, nullable=False)
    
    # Context
    related_entity = Column(String(50))  # certificate, job_card, branding, etc.
    related_entity_id = Column(Integer)
    
    # Status
    is_acknowledged = Column(Boolean, default=False)
    acknowledged_by = Column(String(100))
    acknowledged_at = Column(DateTime)
    
    # Resolution
    is_resolved = Column(Boolean, default=False)
    resolved_by = Column(String(100))
    resolved_at = Column(DateTime)
    resolution_notes = Column(Text)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime)
    
    # Relationships
    plan = relationship("NightPlan", back_populates="alerts")
    
    def __repr__(self):
        return f"<Alert {self.title}>"
    
    def to_dict(self):
        return {
            "id": self.id,
            "plan_id": self.plan_id,
            "train_id": self.train_id,
            "alert_type": self.alert_type,
            "severity": self.severity.value if self.severity else None,
            "title": self.title,
            "message": self.message,
            "related_entity": self.related_entity,
            "related_entity_id": self.related_entity_id,
            "is_acknowledged": self.is_acknowledged,
            "acknowledged_by": self.acknowledged_by,
            "is_resolved": self.is_resolved,
            "resolved_by": self.resolved_by,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "expires_at": self.expires_at.isoformat() if self.expires_at else None
        }

